# OpenCV+ë…¸íŠ¸ë¶ ì¹´ë©”ë¼+look at

Reachy Miniì˜ ì¹´ë©”ë¼ë¥¼ í†µí•´ **ì‹¤ì‹œê°„ìœ¼ë¡œ ê°€ì¥ ë°ì€ ë¬¼ì²´ë¥¼ ì°¾ì•„ ê·¸ ë°©í–¥ìœ¼ë¡œ ê³ ê°œë¥¼ ëŒë¦¬ëŠ” ì‹œê° ì¶”ì (Visual Tracking) ë¡œì§**ì…ë‹ˆë‹¤.

 **"ì¸ì‹ -> ê³„ì‚° -> í–‰ë™"**ì´ë¼ëŠ” ë¡œë´‡ ì œì–´ì˜ ê¸°ë³¸ ë£¨í”„ë¥¼ 

---

### 1. ì‹œê° ì¸ì‹ ë‹¨ê³„ (OpenCV í™œìš©)

ì¹´ë©”ë¼ë¡œ ë“¤ì–´ì˜¤ëŠ” 2ì°¨ì› ì´ë¯¸ì§€ í”„ë ˆì„ì—ì„œ ì¶”ì í•  ëŒ€ìƒì„ ì°¾ëŠ” ê³¼ì •ì…ë‹ˆë‹¤.

- **`gray = cv2.cvtColor(...)`**: ì»¬ëŸ¬ ì´ë¯¸ì§€ë¥¼ í‘ë°±(Grayscale)ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤. ë°ê¸° ì •ë³´ë§Œ ë‚¨ê²¨ì„œ ì—°ì‚° ì†ë„ë¥¼ ë†’ì…ë‹ˆë‹¤.
- **`cv2.threshold(gray, 200, 255, ...)`**: ë°ê¸° ê°’ì´ 200 ì´ìƒì¸ ì§€ì (ë§¤ìš° ë°ì€ ë¶€ë¶„)ë§Œ í°ìƒ‰(255)ìœ¼ë¡œ ë§Œë“¤ê³  ë‚˜ë¨¸ì§€ëŠ” ê²€ì€ìƒ‰(0)ìœ¼ë¡œ ì§€ì›ë‹ˆë‹¤. ì¦‰, **"ë¹›ë‚˜ëŠ” ë¬¼ì²´"ë§Œ ì¶”ì¶œ**í•˜ëŠ” í•„í„°ë§ì…ë‹ˆë‹¤.
- **`cv2.findContours(...)`**: í°ìƒ‰ìœ¼ë¡œ ì¶”ì¶œëœ ì˜ì—­ë“¤ì˜ ì™¸ê³½ì„ ì„ ì°¾ì•„ëƒ…ë‹ˆë‹¤.
- **`max(contours, key=cv2.contourArea)`**: í™”ë©´ì— ì—¬ëŸ¬ ë°ì€ ì ì´ ìˆì„ ê²½ìš°, ê·¸ì¤‘ **ê°€ì¥ í¬ê¸°ê°€ í° ì˜ì—­**ì„ ì¶”ì  ëŒ€ìƒìœ¼ë¡œ ì„ ì •í•©ë‹ˆë‹¤.

### 2. ìœ„ì¹˜ ê³„ì‚° ë‹¨ê³„ (Moments ê³„ì‚°)

ì„ íƒëœ ì˜ì—­ì˜ ì •ì¤‘ì•™ ì¢Œí‘œë¥¼ êµ¬í•˜ëŠ” ê³¼ì •ì…ë‹ˆë‹¤.

- **`M = cv2.moments(...)`**: ì´ë¯¸ì§€ ëª¨ë©˜íŠ¸ë¥¼ ê³„ì‚°í•˜ì—¬ ë„í˜•ì˜ ì§ˆëŸ‰ ì¤‘ì‹¬ì„ êµ¬í•©ë‹ˆë‹¤.
- **`cX, cY`**: ê²°ê³¼ì ìœ¼ë¡œ ì´ë¯¸ì§€ ìƒì˜ **í”½ì…€ ì¢Œí‘œ(ê°€ë¡œ x, ì„¸ë¡œ y)**ê°€ ë„ì¶œë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ì¹´ë©”ë¼ í•´ìƒë„ê°€ 640x480ì´ë¼ë©´ `(320, 240)` ê·¼ì²˜ê°€ í™”ë©´ ì¤‘ì•™ì´ ë©ë‹ˆë‹¤.

### 3. ë¡œë´‡ ì œì–´ ë‹¨ê³„ (Look At ì‹¤í–‰)

ê³„ì‚°ëœ 2ì°¨ì› í”½ì…€ ì¢Œí‘œë¥¼ ë¡œë´‡ì˜ ë¬¼ë¦¬ì ì¸ ê´€ì ˆ ì›€ì§ì„ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

- **`reachy.look_at_image(cX, cY, ...)`**: ì´ í•¨ìˆ˜ê°€ ì´ ì½”ë“œì˜ í•µì‹¬ì…ë‹ˆë‹¤.
    - ë³´í†µ ë¡œë´‡ ì œì–´ì—ëŠ” 3ì°¨ì› ì¢Œí‘œ($x, y, z$)ê°€ í•„ìš”í•˜ì§€ë§Œ, ì´ í•¨ìˆ˜ëŠ” **ì´ë¯¸ì§€ ìƒì˜ 2D ì¢Œí‘œë§Œ ë„£ì–´ì£¼ë©´** ë¡œë´‡ì´ ê·¸ ì§€ì ì„ ì¤‘ì•™ì— ë§ì¶”ê¸° ìœ„í•´ ëª© ê´€ì ˆì„ ì–¼ë§ˆë‚˜ ì›€ì§ì—¬ì•¼ í• ì§€ ë‚´ë¶€ì ìœ¼ë¡œ ì—­ê¸°êµ¬í•™(IK)ì„ í’€ì–´ ì‹¤í–‰í•©ë‹ˆë‹¤.
- **`look_interval = 0.5`**: ë§¤ í”„ë ˆì„ë§ˆë‹¤(ì´ˆë‹¹ 30íšŒ ì´ìƒ) ëª©ì„ ì›€ì§ì´ë©´ ëª¨í„°ì— ë¬´ë¦¬ê°€ ê°€ê³  ë™ì‘ì´ ë–¨ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ **0.5ì´ˆì˜ ê°„ê²©**ì„ ë‘ì–´ ë™ì‘ì„ ë¶€ë“œëŸ½ê³  ì•ˆì •ì ìœ¼ë¡œ ë§Œë“­ë‹ˆë‹¤.

---

### ğŸ’¡ ì½”ë“œì˜ íŠ¹ì§• ë° íŒ

1. **ë™ì‘ ë°©ì‹:** ì´ ì½”ë“œëŠ” "ë¹›"ì„ ë”°ë¼ê°€ëŠ” ë‚˜ë°©ê³¼ ê°™ì€ ë©”ì»¤ë‹ˆì¦˜ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. ì‹œë®¬ë ˆì´ì…˜ í™˜ê²½ì— ë°ì€ ê³µì´ë‚˜ ì¡°ëª…ì„ ë°°ì¹˜í•˜ë©´ Reachyê°€ ê·¸ê²ƒì„ ì¡¸ì¡¸ ë”°ë¼ë‹¤ë‹ˆê²Œ ë©ë‹ˆë‹¤.
2. **ì˜ˆì™¸ ì²˜ë¦¬:** `try...except` êµ¬ë¬¸ì„ ì‚¬ìš©í•´ ë¡œë´‡ì´ ë°”ë¼ë³¼ ìˆ˜ ì—†ëŠ” ê°ë„(ê´€ì ˆ í•œê³„ì )ì— ì¢Œí‘œê°€ ì°íˆë”ë¼ë„ í”„ë¡œê·¸ë¨ì´ ë©ˆì¶”ì§€ ì•Šê³  ê³„ì† ì‹¤í–‰ë˜ë„ë¡ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.
3. **ê°œì„  ì œì•ˆ:** ë§Œì•½ ë¬¼ì²´ê°€ ë„ˆë¬´ ë¹¨ë¦¬ ì›€ì§ì—¬ì„œ ì¶”ì ì„ ë†“ì¹œë‹¤ë©´ `look_interval`ì„ `0.2` ì •ë„ë¡œ ì¤„ì—¬ë³´ì„¸ìš”. ë°˜ëŒ€ë¡œ ë„ˆë¬´ ëœëœ ë–¨ë¦°ë‹¤ë©´ `duration`ì„ ì¢€ ë” ê¸¸ê²Œ ì£¼ì–´ ë¶€ë“œëŸ½ê²Œ ì›€ì§ì´ê²Œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ ì½”ë“œë¥¼ ì‹¤í–‰í•  ë•Œ MuJoCo ì‹œë‚˜ë¦¬ì˜¤ì— **í°ìƒ‰ êµ¬ì²´(Sphere)**ë¥¼ í•˜ë‚˜ ë„ì›Œë‘ê³  ë§ˆìš°ìŠ¤ë¡œ ì˜®ê²¨ë³´ì‹œë©´ Reachyê°€ ê³ ê°œë¥¼ ëŒë ¤ ë°˜ì‘í•˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë” ê¶ê¸ˆí•œ êµ¬í˜„ ë‚´ìš©ì´ë‚˜ ìˆ˜ì •í•˜ê³  ì‹¶ì€ ë¶€ë¶„ì´ ìˆìœ¼ì‹ ê°€ìš”? (ì˜ˆ: íŠ¹ì • ìƒ‰ìƒë§Œ ì¶”ì í•˜ê¸° ë“±)

`reachy.look_at_image()` í•¨ìˆ˜ëŠ” Reachy SDKì—ì„œ ì œê³µí•˜ëŠ” ê°€ì¥ ê°•ë ¥í•˜ê³  í¸ë¦¬í•œ ê¸°ëŠ¥ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.

ì¼ë°˜ì ìœ¼ë¡œ ë¡œë´‡ì´ íŠ¹ì • ëŒ€ìƒì„ ë°”ë¼ë³´ê²Œ í•˜ë ¤ë©´ **2D ì´ë¯¸ì§€ ì¢Œí‘œ â†’ 3D ê³µê°„ ì¢Œí‘œ â†’ ê° ê´€ì ˆì˜ ê°ë„(ì—­ê¸°êµ¬í•™)**ë¼ëŠ” ë³µì¡í•œ ê³„ì‚° ê³¼ì •ì„ ê±°ì³ì•¼ í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ í•¨ìˆ˜ëŠ” **"í™”ë©´ì˜ ì–´ë””ë¥¼ ë³¼ì§€"**ë§Œ ì•Œë ¤ì£¼ë©´ ì´ ëª¨ë“  ê³¼ì •ì„ ë‚´ë¶€ì—ì„œ ìë™ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.

---

### 4. í•¨ìˆ˜ì˜ ì£¼ìš” íŒŒë¼ë¯¸í„°

Python

`reachy.head.look_at_image(x, y, duration=1.0, perform_movement=True)`

- **`x`, `y`**: ì¹´ë©”ë¼ í”„ë ˆì„ ìƒì˜ **í”½ì…€ ì¢Œí‘œ**ì…ë‹ˆë‹¤.
    - ì˜ˆë¥¼ ë“¤ì–´, ì¹´ë©”ë¼ í•´ìƒë„ê°€ $640 \times 480$ì¼ ë•Œ í™”ë©´ ì •ì¤‘ì•™ì„ ë³´ê²Œ í•˜ë ¤ë©´ `(320, 240)`ì„ ì…ë ¥í•©ë‹ˆë‹¤.
- **`duration`**: í•´ë‹¹ ì§€ì ì„ ë°”ë¼ë³´ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„(ì´ˆ)ì…ë‹ˆë‹¤. ê°’ì´ ì‘ì„ìˆ˜ë¡ ê³ ê°œë¥¼ ë¹ ë¥´ê²Œ ëŒë¦½ë‹ˆë‹¤.
- **`perform_movement`**:
    - `True`: í•¨ìˆ˜ í˜¸ì¶œ ì¦‰ì‹œ ë¡œë´‡ì´ ê³ ê°œë¥¼ ì›€ì§ì…ë‹ˆë‹¤.
    - `False`: ì›€ì§ì´ì§€ ì•Šê³ , í•´ë‹¹ ì§€ì ì„ ë³´ê¸° ìœ„í•´ í•„ìš”í•œ **ê´€ì ˆ ê°ë„ê°’**ë§Œ ê³„ì‚°í•´ì„œ ë°˜í™˜í•©ë‹ˆë‹¤.

---

### 5. ì‘ë™ ì›ë¦¬ (ë‚´ë¶€ ë©”ì»¤ë‹ˆì¦˜)

ì´ í•¨ìˆ˜ëŠ” ë‹¨ìˆœíˆ ê³ ê°œë¥¼ ëŒë¦¬ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ë‹¤ìŒê³¼ ê°™ì€ ê³ ë„ì˜ ê³„ì‚°ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

1. **ì‹œê°ì  ì •ë ¬ (Visual Alignment):** ì¹´ë©”ë¼ì˜ í™”ê°(Field of View)ê³¼ í˜„ì¬ ë¨¸ë¦¬ì˜ ìì„¸ë¥¼ ë°”íƒ•ìœ¼ë¡œ, ì…ë ¥ëœ $(x, y)$ í”½ì…€ì´ ì‹¤ì œ 3ì°¨ì› ê³µê°„ì˜ ì–´ëŠ ë°©í–¥ì¸ì§€ ê³„ì‚°í•©ë‹ˆë‹¤.
2. **ì—­ê¸°êµ¬í•™ (Inverse Kinematics):** Reachyì˜ ëª© ê´€ì ˆ(Orbital Neck) êµ¬ì¡°ë¥¼ ê³ ë ¤í•˜ì—¬, í•´ë‹¹ ë°©í–¥ì„ ì¹´ë©”ë¼ ì •ì¤‘ì•™ì— ìœ„ì¹˜ì‹œí‚¤ê¸° ìœ„í•œ `neck_roll`, `neck_pitch`, `neck_yaw` ê°ë„ë¥¼ ì‚°ì¶œí•©ë‹ˆë‹¤.
3. **ê¶¤ì  ìƒì„± (Trajectory):** ì„¤ì •ëœ `duration` ë™ì•ˆ ë¶€ë“œëŸ½ê²Œ ì›€ì§ì´ë„ë¡ ëª¨í„°ë¥¼ ì œì–´í•©ë‹ˆë‹¤.

---

### 6. ì™œ `look_at()` ëŒ€ì‹  `look_at_image()`ë¥¼ ì“°ë‚˜ìš”?

- **`look_at(x, y, z)`**: ë¡œë´‡ì˜ ëª¸ì²´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ **ì‹¤ì œ ë¬¼ë¦¬ì  ê±°ë¦¬(ë¯¸í„° ë‹¨ìœ„)**ë¥¼ ì•Œ ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. (ì˜ˆ: "ë‚´ ì• 50cm ì§€ì ì„ ë´")
- **`look_at_image(x, y)`**: ê±°ë¦¬(ê¹Šì´) ì •ë³´ëŠ” ëª¨ë¥´ì§€ë§Œ, **ì¹´ë©”ë¼ í™”ë©´ì— ì°íŒ ìœ„ì¹˜**ë§Œ ì•Œ ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. (ì˜ˆ: "í™”ë©´ ì™¼ìª½ ìƒë‹¨ì— ì°íŒ ì € ë¬¼ì²´ë¥¼ ë´")

ì¦‰, OpenCVë¡œ ë¬¼ì²´ë¥¼ ì¸ì‹í•´ì„œ ì¶”ì í•  ë•ŒëŠ” `look_at_image()`ê°€ í›¨ì”¬ ì§ê´€ì ì´ê³  í¸ë¦¬í•©ë‹ˆë‹¤.

---

### 7. ì‹¤ì „ ì‚¬ìš© íŒ

- **ì¤‘ì‹¬ì  ë³´ì •:** `(cX, cY)` ì¢Œí‘œë¥¼ ê·¸ëŒ€ë¡œ ë„£ìœ¼ë©´ ReachyëŠ” ê·¸ ë¬¼ì²´ê°€ í™”ë©´ì˜ **ì •ì¤‘ì•™**ì— ì˜¤ë„ë¡ ê³ ê°œë¥¼ ì›€ì§ì…ë‹ˆë‹¤.
- **ë¶€ë“œëŸ¬ìš´ ì¶”ì :** ë£¨í”„ ì•ˆì—ì„œ ì‹¤ì‹œê°„ ì¶”ì ì„ í•  ë•ŒëŠ” `duration`ì„ `0.1` ~ `0.3` ì •ë„ë¡œ ì§§ê²Œ ì„¤ì •í•´ì•¼ ëŠê¹€ ì—†ì´ ë¶€ë“œëŸ½ê²Œ ëŒ€ìƒì„ ì«“ì•„ê°‘ë‹ˆë‹¤.

> ì£¼ì˜: ë§Œì•½ ì…ë ¥í•œ $(x, y)$ ì¢Œí‘œê°€ ë¡œë´‡ì´ ë¬¼ë¦¬ì ìœ¼ë¡œ ê³ ê°œë¥¼ ëŒë¦´ ìˆ˜ ì—†ëŠ” í•œê³„ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ ì—ëŸ¬ê°€ ë°œìƒí•˜ê±°ë‚˜ ë™ì‘í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> 

---

ì´ì œ `look_at_image()`ë¥¼ ì‚¬ìš©í•˜ì—¬ Reachyê°€ ë¬¼ì²´ë¥¼ ë”°ë¼ê°€ëŠ” ì§€ëŠ¥ì ì¸ ì‹œì„ ì„ ê°–ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. í˜¹ì‹œ **ë¡œë´‡ì´ ë¬¼ì²´ë¥¼ ë°”ë¼ë³¸ ìƒíƒœì—ì„œ ì†(íŒ”)ì„ ê·¸ ë¬¼ì²´ ìª½ìœ¼ë¡œ ë»—ê²Œ í•˜ëŠ” ê¸°ëŠ¥**ë„ ê¶ê¸ˆí•˜ì‹ ê°€ìš”? ê´€ë ¨í•´ì„œ ë„ì›€ì„ ë“œë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤!

```python
from reachy_mini import ReachyMini
import time
import cv2
import numpy as np
from reachy_mini.media.camera_opencv import OpenCVCamera
from reachy_mini.media.camera_constants import MujocoCameraSpecs, CameraSpecs
from typing import cast

def track_with_laptop_camera(reachy, duration=30, threshold=200):
    """
    ë…¸íŠ¸ë¶ ì›¹ìº ì„ ì‚¬ìš©í•˜ì—¬ ê°ì²´ ì¶”ì  ë° ë””ìŠ¤í”Œë ˆì´
    
    Args:
        reachy: ReachyMini ì¸ìŠ¤í„´ìŠ¤
        duration: ì¶”ì  ì‹œê°„ (ì´ˆ)
        threshold: ë°ê¸° ì„ê³„ê°’
    """
    # ë…¸íŠ¸ë¶ ì›¹ìº  ì„¤ì •
    if reachy.media.camera is not None:
        reachy.media.camera.close()
    
    laptop_camera = OpenCVCamera(log_level="INFO")
    laptop_camera.cap = cv2.VideoCapture(0)  # ë…¸íŠ¸ë¶ ì›¹ìº 
    
    if not laptop_camera.cap.isOpened():
        print("âŒ ë…¸íŠ¸ë¶ ì›¹ìº ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        return
    
    laptop_camera.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
    laptop_camera.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)
    laptop_camera.camera_specs = cast(CameraSpecs, MujocoCameraSpecs)
    laptop_camera._resolution = laptop_camera.camera_specs.default_resolution
    laptop_camera.resized_K = laptop_camera.camera_specs.K
    
    reachy.media.camera = laptop_camera
    
    print(f"âœ… ë…¸íŠ¸ë¶ ì›¹ìº ìœ¼ë¡œ ê°ì²´ ì¶”ì  ì‹œì‘ (ì§€ì† ì‹œê°„: {duration}ì´ˆ)")
    print("'q' í‚¤ë¥¼ ëˆ„ë¥´ë©´ ì¢…ë£Œë©ë‹ˆë‹¤.")
    
    start_time = time.time()
    last_look_time = time.time()
    look_interval = 0.5
    tracked_position = None
    
    try:
        while time.time() - start_time < duration:
            frame = reachy.media.get_frame()
            if frame is None:
                continue
            
            display_frame = frame.copy()
            
            # ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            
            # ë°ì€ ì˜ì—­ ì°¾ê¸°
            _, thresh = cv2.threshold(gray, threshold, 255, cv2.THRESH_BINARY)
            
            # ì»¨íˆ¬ì–´ ì°¾ê¸°
            contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            
            if contours:
                largest_contour = max(contours, key=cv2.contourArea)
                area = cv2.contourArea(largest_contour)
                
                if area > 100:  #ë©´ì ì´ 100 ì´ìƒ ì¼ë•Œë•Œ
                    M = cv2.moments(largest_contour)  # ëª¨ë©˜íŠ¸ ê°’ ë”•ì…”ë„ˆë¦¬ë¦¬
                    if M["m00"] != 0:                 #m00:ë¬¼ì²´ì˜ ì „ì²´ ë©´ì ì 
                        cX = int(M["m10"] / M["m00"]) #m10:xì¶• ë°©í–¥ì˜ 1ì°¨ ëª¨ë©˜íŠ¸
                        cY = int(M["m01"] / M["m00"]) #m01:yì¶• ë°©í–¥ì˜ 1ì°¨ ëª¨ë©˜íŠ¸
                        tracked_position = (cX, cY)   #ì¤‘ì‹¬ì ê³„ì‚°
                        
                        # ì»¨íˆ¬ì–´ ë° ì¤‘ì‹¬ì  í‘œì‹œ
                        cv2.drawContours(display_frame, [largest_contour], -1, (0, 255, 0), 2)
                        cv2.circle(display_frame, (cX, cY), 10, (0, 0, 255), -1)
                        cv2.circle(display_frame, (cX, cY), 15, (0, 0, 255), 2)
                        cv2.putText(display_frame, f"({cX}, {cY})", 
                                   (cX + 20, cY - 20), 
                                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
                        
                        # look_at ì‹¤í–‰
                        if time.time() - last_look_time > look_interval:
                            try:
                                reachy.look_at_image(cX, cY, duration=0.3, perform_movement=True)
                                last_look_time = time.time()
                                print(f"  â†’ ({cX}, {cY}) ìœ„ì¹˜ë¥¼ ë°”ë¼ë´„")
                            except Exception as e:
                                print(f"  ê²½ê³ : {e}")
            
            # ì¤‘ì•™ ì‹­ìì„ 
            h, w = display_frame.shape[:2]
            cv2.line(display_frame, (w//2, 0), (w//2, h), (255, 255, 0), 1)
            cv2.line(display_frame, (0, h//2), (w, h//2), (255, 255, 0), 1)
            
            # ì •ë³´ í…ìŠ¤íŠ¸
            elapsed_time = int(time.time() - start_time)
            info_text = [
                f"Laptop Camera (Sim Mode)",
                f"Time: {elapsed_time}/{duration}s",
                f"Tracked: {tracked_position if tracked_position else 'None'}"
            ]
            for i, text in enumerate(info_text):
                cv2.putText(display_frame, text, (10, 30 + i * 25),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
            
            cv2.imshow("Laptop Camera Tracking (Sim)", display_frame)
            
            if cv2.waitKey(1) & 0xFF == ord('q'):
                print("ì‚¬ìš©ìê°€ ì¢…ë£Œë¥¼ ìš”ì²­í–ˆìŠµë‹ˆë‹¤.")
                break
            
            time.sleep(0.03)
    
    except KeyboardInterrupt:
        print("ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.")
    finally:
        cv2.destroyAllWindows()
        print("ì¶”ì  ì™„ë£Œ")

# ì‚¬ìš© ì˜ˆì‹œ
with ReachyMini() as reachy:
    track_with_laptop_camera(reachy, duration=30, threshold=200)
```
